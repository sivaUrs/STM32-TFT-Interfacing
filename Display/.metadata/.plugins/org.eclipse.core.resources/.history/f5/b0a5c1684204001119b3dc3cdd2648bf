/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2026 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "stm32f407xx.h"
#include "reg_util.h"

void SystemClockSetup();

int main(void)
{
	SystemClockSetup();

	GPIOD->MODER |= GPIO_MODER_MODER12_0; // Green LED, set pin 12 as output
	GPIOD->MODER |= GPIO_MODER_MODER13_0; // Orange LED, set pin 13 as output
	GPIOD->MODER |= GPIO_MODER_MODER14_0; // Red LED, set pin 14 as output
	GPIOD->MODER |= GPIO_MODER_MODER15_0; // Blue LED, set pin 15 as output

	unsigned int i;

    /* Loop forever */
	for(;;){

		// Turn on LEDs
		GPIOD->BSRR = 1<<12; // Set the BSRR bit 12 to 1 to turn respective LED on
		GPIOD->BSRR = 1<<13; // Set the BSRR bit 13 to 1 to turn respective LED on
		GPIOD->BSRR = 1<<14; // Set the BSRR bit 14 to 1 to turn respective LED on
		GPIOD->BSRR = 1<<15; // Set the BSRR bit 15 to 1 to turn respective LED on

		// Delay
		for(i = 0; i < 2000000; i++){

		} // Loop repeats 2,000,000 implementing a delay

		// Turn off LEDs
		GPIOD->BSRR = 1<<(12+16); // Set the BSRR bit 12 + 16 to 1 to turn respective LED off
		GPIOD->BSRR = 1<<(13+16); // Set the BSRR bit 13 + 16 to 1 to turn respective LED off
		GPIOD->BSRR = 1<<(14+16); // Set the BSRR bit 14 + 16 to 1 to turn respective LED off
		GPIOD->BSRR = 1<<(15+16); // Set the BSRR bit 15 + 16 to 1 to turn respective LED off

		// Delay
		for(i = 0; i < 2000000; i++){} // Loop repeats 2,000,000 implementing a delay

	}
}

void SystemClockSetup(void)
{
	RCC_TypeDef *pRCC = RCC;
	FLASH_TypeDef *pFLASH = FLASH_ACR;
	PWR_TypeDef *pPWR = PWR;
	GPIO_TypeDef *pGPIOA = GPIOA;

	/*setting access control register to set 5 wait cycles.*/
	REG_SET_VAL(pFLASH->ACR,FLASH_ACR_LATENCY_5WS, FLASH_ACR_LATENCY_Msk, FLASH_ACR_LATENCY_Pos);

	/*Enabling the clock to access power control register*/
	REG_SET_BIT(pRCC->APB1ENR, RCC_APB1ENR_PWREN_Pos);

	/*setting VOS bit to 1 to achieve 168 MHZ frequency in PLL mode*/
	REG_SET_BIT(pPWR->CR, PWR_CR_VOS_Pos);

	/*configure PLL registers to get 168MHZ max*/
	REG_SET_VAL(pRCC->PLLCFGR, 16U, RCC_PLLCFGR_PLLM_Msk, RCC_PLLCFGR_PLLM_Pos);  /*PLL_M*/
	REG_SET_VAL(pRCC->PLLCFGR, 0x01U, RCC_PLLCFGR_PLLN_Msk, RCC_PLLCFGR_PLLN_Pos);  /*PLL_N*/
	REG_SET_VAL(pRCC->PLLCFGR, 0x03U, RCC_PLLCFGR_PLLP_Msk, RCC_PLLCFGR_PLLP_Pos);  /*PLL_P*/

    /* configure AHB and APBx prescalers*/
	REG_SET_VAL(pRCC->CFGR, RCC_CFGR_HPRE_DIV1,  RCC_CFGR_HPRE_Msk,  RCC_CFGR_HPRE_Pos); /* HCLK 168MHZ no division*/
  	REG_SET_VAL(pRCC->CFGR, RCC_CFGR_PPRE2_DIV1, RCC_CFGR_PPRE2_Msk, RCC_CFGR_PPRE2_Pos);/* PCLK2 168MHZ no division*/
	REG_SET_VAL(pRCC->CFGR, RCC_CFGR_PPRE1_DIV2, RCC_CFGR_PPRE1_Msk, RCC_CFGR_PPRE1_Pos);/* PCLK1 84MHZ HCLK/2 */

	/*Turn on PLL and wait for the PLL to be ready*/
	REG_SET_BIT(pRCC->CR, RCC_CR_PLLON_Pos);
	while(!REG_READ_BIT(pRCC->CR,RCC_CR_PLLRDY_Pos));

	/*Set system clock source as PLL and wait for the configuration*/
	REG_SET_VAL(pRCC->CFGR, 0x2U, RCC_CFGR_SW_Msk, RCC_CFGR_SW_Pos);
	while((REG_READ_VAL(pRCC->CFGR, 0x03U, RCC_CFGR_SWS_Pos) != 0x02U));

	/* setting clock out on MCO1(PA8) pin*/
	REG_SET_VAL(pRCC->CFGR, 0x03U,  RCC_CFGR_MCO1_Msk,  RCC_CFGR_MCO1_Pos);
	REG_SET_VAL(pRCC->CFGR, 0x07U,  RCC_CFGR_MCO1PRE_Msk,  RCC_CFGR_MCO1PRE_Pos);

	RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN; // Enable the clock of port D of the GPIO

	REG_SET_VAL(pGPIOA->MODER, 0x02U, GPIO_MODER_MODER8_Msk, GPIO_MODER_MODER8_Pos);
	REG_SET_VAL(pGPIOA->OSPEEDR, 0x03U, GPIO_OSPEEDR_OSPEED8_Msk, GPIO_OSPEEDR_OSPEED8_Pos);
	REG_SET_VAL(pGPIOA->PUPDR, 0x00U, GPIO_OSPEEDR_OSPEED8_Msk, GPIO_PUPDR_PUPD8_Pos);

}
